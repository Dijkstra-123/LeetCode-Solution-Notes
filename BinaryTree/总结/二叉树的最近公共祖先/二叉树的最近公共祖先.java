package BinaryTree.总结.二叉树的最近公共祖先;

/*

二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”



示例 1：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3：

输入：root = [1,2], p = 1, q = 2
输出：1


提示：

树中节点数目在范围 [2, 105] 内。
        -109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。
相关标签

        Java



作者：LeetCode
链接：https://leetcode.cn/leetbook/read/data-structure-binary-tree/xopaih/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

*/


public class 二叉树的最近公共祖先 {

}



/*

合并思想，递归函数结束返回的过程与向上搜索的过程类似重叠
首先找到是必须摸到的，应为人看程序其实是一个黑箱，要抽象就是可以的
但是向上的再查是没有必要的，可以和递归函数的结束一起合并，直接还模拟了回到根
题解合并成功


----------------------------------------------------------------------

后来又做了一次
我还是没有做出来
其原因是我没有把一些情况给搞明白，就是没有列举出全部的情况
根据我的思考，我觉得即使我只是思考了局部的，但是没有考虑整体的

整体思想（蕴含局部概念）
把局部和整体分开来（举例子）
局部不可能出现的情况却可能在整体的其它地方出现（还是有待练习）
其实局部就是最基础的一些情况

递归其实就是把所有的情况塞在一起
一些答案的简洁就是写出来后化简的结果

特别的是
不止有一个终止条件

两个目标其中一个是最近的父节点的情况就是————可以简化为之查找到最上面的那个就行


举例子在这里占用了很大的部分
举例子是很重要的

*/
